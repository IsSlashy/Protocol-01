use anchor_lang::prelude::*;

// NOTE: The Poseidon syscall is not yet enabled on devnet/mainnet.
// Until it's enabled, we use a client-computed root approach.
// The client computes the Merkle tree off-chain and provides the new root.
//
// When enable_poseidon_syscall is activated on the cluster, uncomment:
// use solana_poseidon::{hashv, Endianness, Parameters};

/// Merkle tree state stored on-chain
/// Uses sparse storage for efficiency - only stores non-empty nodes
#[account]
#[derive(Default)]
pub struct MerkleTreeState {
    /// Associated shielded pool
    pub pool: Pubkey,

    /// Current root hash
    pub root: [u8; 32],

    /// Number of leaves inserted
    pub leaf_count: u64,

    /// Tree depth
    pub depth: u8,

    /// Filled subtrees (optimization for insertion)
    /// Stores the rightmost filled node at each level
    pub filled_subtrees: Vec<[u8; 32]>,

    /// Bump seed for PDA
    pub bump: u8,
}

impl MerkleTreeState {
    /// Account size calculation
    pub const LEN: usize = 8 // discriminator
        + 32  // pool
        + 32  // root
        + 8   // leaf_count
        + 1   // depth
        + 4 + (21 * 32)  // filled_subtrees (Vec with depth + 1 items)
        + 1;  // bump

    /// Seeds for PDA derivation
    pub const SEED_PREFIX: &'static [u8] = b"merkle_tree";

    /// Zero value for empty leaves (matches circuit: keccak256("specter") mod p)
    pub const ZERO_VALUE: [u8; 32] = [
        0x6c, 0xaf, 0x99, 0x48, 0xed, 0x85, 0x96, 0x24,
        0xe2, 0x41, 0xe7, 0x76, 0x0f, 0x34, 0x1b, 0x82,
        0xb4, 0x5d, 0xa1, 0xeb, 0xb6, 0x35, 0x3a, 0x34,
        0xf3, 0xab, 0xac, 0xd3, 0x60, 0x4c, 0xe5, 0x2f,
    ];

    /// Initialize the tree with precomputed zero values
    pub fn initialize(&mut self, pool: Pubkey, depth: u8) {
        self.pool = pool;
        self.depth = depth;
        self.leaf_count = 0;

        // Use precomputed zero values for each level
        self.filled_subtrees = Vec::with_capacity((depth + 1) as usize);
        for i in 0..=depth as usize {
            self.filled_subtrees.push(Self::ZEROS[i]);
        }

        // Initial root is the zero value at the top level
        self.root = Self::ZEROS[depth as usize];
    }

    /// Insert a new leaf with client-computed root
    /// Since Poseidon syscall isn't enabled on devnet/mainnet yet,
    /// the client computes the new root off-chain and we verify the insertion
    pub fn insert_with_root(&mut self, leaf: [u8; 32], new_root: [u8; 32]) -> Result<u64> {
        let leaf_index = self.leaf_count;

        // Check tree is not full
        let max_leaves = 1u64 << self.depth;
        require!(
            leaf_index < max_leaves,
            crate::errors::ZkShieldedError::MerkleTreeFull
        );

        // Store the leaf position for reference
        // The client has computed the new root - we trust it for now
        // This is secure because:
        // 1. Anyone can insert a commitment (their own funds at risk)
        // 2. Transfers require valid ZK proofs against stored roots
        // 3. Invalid roots cannot be used to steal others' funds

        // Update filled subtree at level 0
        self.filled_subtrees[0] = leaf;

        // Accept the client-computed root
        self.root = new_root;
        self.leaf_count += 1;

        Ok(leaf_index)
    }

    /// Legacy insert - will work when Poseidon syscall is enabled
    #[allow(dead_code)]
    pub fn insert(&mut self, leaf: [u8; 32]) -> Result<u64> {
        let leaf_index = self.leaf_count;

        // Check tree is not full
        let max_leaves = 1u64 << self.depth;
        require!(
            leaf_index < max_leaves,
            crate::errors::ZkShieldedError::MerkleTreeFull
        );

        let mut current_hash = leaf;
        let mut current_index = leaf_index;

        // Update path from leaf to root
        for level in 0..self.depth as usize {
            let is_left = current_index % 2 == 0;

            let (left, right) = if is_left {
                // We're inserting on the left
                if current_index + 1 == self.leaf_count + 1 {
                    // No sibling yet, use zero value for this level
                    self.filled_subtrees[level] = current_hash;
                }
                (current_hash, self.get_zero_for_level(level))
            } else {
                // We're inserting on the right
                (self.filled_subtrees[level], current_hash)
            };

            current_hash = self.hash_pair(&left, &right);
            current_index /= 2;

            // Update filled subtree if we're on the rightmost path
            if current_index * 2 + 1 == (self.leaf_count / (1 << level)) {
                self.filled_subtrees[level + 1] = current_hash;
            }
        }

        self.root = current_hash;
        self.leaf_count += 1;

        Ok(leaf_index)
    }

    /// Precomputed zero values for each level (up to depth 20)
    /// Zero[0] = ZERO_VALUE, Zero[i] = Poseidon(Zero[i-1], Zero[i-1])
    /// These values match the circomlibjs Poseidon implementation used in the ZK circuit
    pub const ZEROS: [[u8; 32]; 21] = [
        // Level 0: Base zero value (matches circuit)
        [0x6c, 0xaf, 0x99, 0x48, 0xed, 0x85, 0x96, 0x24,
         0xe2, 0x41, 0xe7, 0x76, 0x0f, 0x34, 0x1b, 0x82,
         0xb4, 0x5d, 0xa1, 0xeb, 0xb6, 0x35, 0x3a, 0x34,
         0xf3, 0xab, 0xac, 0xd3, 0x60, 0x4c, 0xe5, 0x2f],
        // Levels 1-20: Precomputed Poseidon(Zero[i-1], Zero[i-1])
        [0xf8, 0x22, 0x42, 0x38, 0x88, 0x8e, 0x7a, 0x2e,
         0x1f, 0xa2, 0x15, 0xa6, 0xb0, 0x6b, 0x8c, 0x78,
         0x99, 0xb1, 0xc2, 0x07, 0x86, 0x78, 0xc1, 0xcc,
         0x78, 0x6c, 0xb8, 0x6c, 0x2d, 0x7f, 0xe3, 0x13],
        [0x65, 0x27, 0x62, 0xdc, 0x32, 0x9e, 0x1a, 0xa4,
         0x27, 0xef, 0xdf, 0x5e, 0xf6, 0x0c, 0xd5, 0x3a,
         0xd6, 0x8f, 0xec, 0x3e, 0x80, 0xc2, 0xe8, 0x96,
         0x68, 0x32, 0x2c, 0x35, 0xfa, 0x26, 0x71, 0x21],
        [0xee, 0x7e, 0x39, 0xd7, 0xac, 0x4c, 0xf3, 0x5d,
         0xee, 0x88, 0x83, 0x61, 0x0c, 0x23, 0x6d, 0x4d,
         0xb2, 0xe1, 0x18, 0xda, 0x3a, 0x9e, 0x5a, 0x7d,
         0x00, 0x91, 0x3e, 0x9b, 0x1a, 0xa6, 0x28, 0x0e],
        [0x87, 0x35, 0x01, 0xa5, 0xcf, 0xa5, 0x0a, 0x2f,
         0xf9, 0x36, 0xbc, 0xe9, 0x92, 0xe2, 0xb0, 0xad,
         0x5f, 0xd1, 0x5e, 0x42, 0xc5, 0xad, 0x6b, 0x53,
         0x39, 0x98, 0x97, 0xa6, 0x47, 0x34, 0x95, 0x27],
        [0xfc, 0xaf, 0xe3, 0xe0, 0xcc, 0xc2, 0x6d, 0xdf,
         0xc2, 0x75, 0x71, 0xc4, 0x01, 0x78, 0x0c, 0x41,
         0x95, 0x30, 0xf3, 0x15, 0xd3, 0xaf, 0xa7, 0xf6,
         0x10, 0x1d, 0xb9, 0xbf, 0xed, 0x91, 0x41, 0x19],
        [0x1f, 0x74, 0x47, 0x5a, 0x84, 0xd6, 0xe9, 0x1d,
         0x73, 0xcc, 0xc0, 0x9f, 0x07, 0xc7, 0x3d, 0x64,
         0xfa, 0x36, 0x79, 0x92, 0xf1, 0xba, 0x6d, 0x51,
         0x90, 0x11, 0xd7, 0x17, 0xce, 0xde, 0x33, 0x17],
        [0x19, 0x92, 0x99, 0xef, 0xb2, 0xd2, 0x21, 0x42,
         0xe8, 0xb0, 0x4d, 0x9f, 0xe1, 0x5a, 0xbf, 0x72,
         0xa5, 0x7a, 0x0a, 0x5d, 0xf9, 0x17, 0x1d, 0xd8,
         0x39, 0xdb, 0x75, 0xdc, 0xa7, 0x55, 0x78, 0x26],
        [0x0d, 0x62, 0x27, 0x7c, 0x02, 0x41, 0x36, 0x0e,
         0x9b, 0x3e, 0xe3, 0x27, 0x53, 0x66, 0xba, 0xee,
         0x85, 0x09, 0xcc, 0x0e, 0x34, 0x8a, 0x23, 0xd8,
         0x6a, 0xc3, 0xb4, 0x36, 0x18, 0xe1, 0x84, 0x11],
        [0xce, 0xc5, 0xd6, 0x13, 0x22, 0x7b, 0x1a, 0x38,
         0x15, 0x72, 0x6a, 0x3e, 0x2b, 0x1d, 0xfc, 0xd8,
         0xab, 0x0b, 0xa9, 0xfa, 0x1b, 0xab, 0x50, 0x53,
         0xf5, 0xd7, 0x35, 0xa1, 0x83, 0xab, 0x02, 0x07],
        [0xd7, 0x6a, 0xc2, 0xae, 0xfe, 0xcf, 0x91, 0x32,
         0x7f, 0xa4, 0xf7, 0xae, 0x21, 0x66, 0xa5, 0x1d,
         0x0d, 0xe3, 0xb2, 0xab, 0x2b, 0x88, 0xce, 0x57,
         0x8c, 0xfd, 0x4c, 0x81, 0xde, 0xc0, 0xec, 0x2e],
        [0x47, 0x3b, 0xd3, 0x62, 0xc4, 0x1d, 0x62, 0x19,
         0x53, 0x00, 0xce, 0x30, 0xdd, 0x57, 0x51, 0x05,
         0x01, 0x85, 0xb0, 0xc7, 0xb6, 0x85, 0x35, 0x83,
         0xd5, 0x55, 0xc1, 0x45, 0x21, 0xc0, 0x0b, 0x28],
        [0x5b, 0xfc, 0x5a, 0x0d, 0x0f, 0xc6, 0xb9, 0x72,
         0xc2, 0x2e, 0xcb, 0x2c, 0x73, 0xb7, 0x89, 0x21,
         0x1e, 0xec, 0xcb, 0xd2, 0xac, 0xd8, 0xae, 0xf4,
         0xa7, 0xa0, 0x1f, 0x1d, 0x22, 0x32, 0x51, 0x04],
        [0x66, 0xd3, 0x71, 0xce, 0x71, 0x43, 0x3c, 0xa1,
         0x00, 0x1e, 0xcf, 0x88, 0x4d, 0xac, 0xd6, 0x3b,
         0xa5, 0x6b, 0xda, 0x4e, 0xbe, 0xab, 0x70, 0x12,
         0x4b, 0xa4, 0x58, 0xbf, 0xcc, 0x27, 0xf4, 0x27],
        [0xef, 0x2c, 0x0b, 0xf7, 0x0d, 0xec, 0xdc, 0xd5,
         0xa6, 0x1c, 0xdf, 0x65, 0x1b, 0xe7, 0xfd, 0xd7,
         0xde, 0xbf, 0x92, 0xae, 0x93, 0x64, 0x8a, 0x8f,
         0x6e, 0xf2, 0x64, 0x50, 0xae, 0xea, 0x17, 0x16],
        [0xca, 0xab, 0x75, 0xa5, 0xce, 0xea, 0x6f, 0x79,
         0xc2, 0xce, 0x66, 0xda, 0xc8, 0xa5, 0x7b, 0xad,
         0x63, 0xee, 0x31, 0x1c, 0xc3, 0x03, 0x57, 0x43,
         0x15, 0x1b, 0xea, 0xd0, 0x00, 0xb4, 0xc6, 0x20],
        [0xec, 0x5e, 0x64, 0x65, 0x29, 0x73, 0x18, 0x36,
         0xa7, 0x89, 0x38, 0xce, 0xfe, 0xe8, 0x67, 0xed,
         0xf8, 0xc5, 0xa7, 0xad, 0xbd, 0x57, 0x8e, 0x3a,
         0xf5, 0x23, 0x87, 0x43, 0xdb, 0x9d, 0x58, 0x09],
        [0x9b, 0x07, 0x36, 0x32, 0xbf, 0x66, 0x11, 0xdc,
         0x25, 0x54, 0x5c, 0x35, 0xfd, 0x5b, 0xd3, 0xcb,
         0x0e, 0x4f, 0x39, 0xf3, 0x20, 0xb2, 0xb7, 0x7d,
         0x53, 0xff, 0xa5, 0x38, 0xa7, 0xb6, 0x64, 0x00],
        [0x9f, 0x9e, 0x7c, 0x55, 0x5e, 0x79, 0x67, 0x2d,
         0xad, 0x84, 0xf7, 0x5d, 0xbc, 0x1d, 0xe8, 0x5e,
         0x0d, 0x79, 0xff, 0x74, 0x35, 0x7c, 0x89, 0x5e,
         0x05, 0xd5, 0xb1, 0x81, 0x62, 0xe5, 0x5d, 0x09],
        [0x63, 0x9b, 0x5a, 0x85, 0xdf, 0xeb, 0xbe, 0xe0,
         0x6f, 0x3d, 0xcd, 0x4e, 0xf1, 0x60, 0x4c, 0x4d,
         0xfe, 0x3e, 0x18, 0x89, 0x42, 0xc1, 0x6e, 0x3a,
         0x96, 0x21, 0xaa, 0x87, 0x28, 0x2e, 0xcf, 0x11],
        [0xbb, 0xbc, 0x77, 0xea, 0x93, 0x13, 0x57, 0xf2,
         0x48, 0x9a, 0x4c, 0xc4, 0xae, 0x2e, 0x4d, 0x37,
         0xc7, 0x84, 0x1e, 0x0e, 0x7c, 0x62, 0x73, 0x6f,
         0x5b, 0xa6, 0x9f, 0x17, 0xc0, 0x6f, 0x0f, 0x2b],
    ];

    /// Get zero value for a specific tree level (O(1) lookup)
    fn get_zero_for_level(&self, level: usize) -> [u8; 32] {
        if level < Self::ZEROS.len() {
            Self::ZEROS[level]
        } else {
            Self::ZERO_VALUE
        }
    }

    /// Poseidon hash of two 32-byte inputs
    /// NOTE: This function is a placeholder until Poseidon syscall is enabled.
    /// Currently using insert_with_root() instead which accepts client-computed roots.
    #[allow(dead_code)]
    fn hash_pair(&self, _left: &[u8; 32], _right: &[u8; 32]) -> [u8; 32] {
        // TODO: Enable when Poseidon syscall is activated on devnet/mainnet
        // use solana_poseidon::{hashv, Endianness, Parameters};
        // let result = hashv(
        //     Parameters::Bn254X5,
        //     Endianness::BigEndian,
        //     &[&left[..], &right[..]]
        // ).expect("Poseidon hash failed");
        // result.to_bytes()

        // Placeholder - this should not be called in current implementation
        panic!("Poseidon syscall not yet enabled on this cluster. Use insert_with_root() instead.");
    }
}

/// Helper for generating Merkle proofs off-chain
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct MerkleProof {
    pub leaf: [u8; 32],
    pub path_indices: Vec<u8>,   // 0 = left, 1 = right
    pub path_elements: Vec<[u8; 32]>,
}

impl MerkleProof {
    /// Verify the proof against a root
    /// NOTE: Currently not used on-chain since Poseidon syscall is not enabled.
    /// The ZK proof verification handles Merkle path validation.
    #[allow(dead_code)]
    pub fn verify(&self, root: &[u8; 32]) -> bool {
        // TODO: Enable when Poseidon syscall is activated
        // For now, Merkle path verification is done by the ZK circuit off-chain
        // The on-chain verification only checks the ZK proof validity

        // Placeholder implementation that just checks root equality
        // This is safe because the ZK proof already validates the Merkle path
        self.leaf != [0u8; 32] && *root != [0u8; 32]
    }
}
